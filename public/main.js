// create variable for local and remote media
let localStream;
let remoteStream;
let peerConnection;
let offer;
let candidatevalue;
let answervalue;

// establish socket connection for signaling
const socket = io("http://localhost:8000");

// STUN server configuration to facilitate NAT traversal
const servers = {
  iceServers: [
    {
      urls: ["stun:stun1.l.google.com:19302", "stun:stun2.l.google.com:19302"],
    },
  ],
};

// getting  local user video and audio data for

const init = async () => {
  // get video and audio stream
  localStream = await navigator.mediaDevices.getUserMedia({
    video: true,
    audio: false,
  });

  // sharing data to ui
  document.getElementById("user-1").srcObject = localStream;
  CreateConnectionAndoffer();
};

//  create a function to create and offer and set up the webRtc connection

const CreateConnectionAndoffer = async () => {
  try {
    // create a new Rtc perr connection  with STUN server configuration
    peerConnection = new RTCPeerConnection(servers);

    //  adding all local user  track to perrconnection
    localStream.getTracks().forEach((track) => {
      // here add tack method add local stream to connection
      peerConnection.addTrack(track, localStream);
    });

    //  createing and event listener for handling and recieving remote user data from peer connection
    remoteStream = new MediaStream(); // create a empty Media Stream for the remore user

    // adding stream to remote from connection
    peerConnection.ontrack = (event) => {
      if (event.streams[0]) {
        event.streams[0].getTracks().forEach((track) => {
          remoteStream.addTrack(track);
        });
      }
    };

    //   displaying the remote user stream in the user-2 video on screen
    document.getElementById("user-2").srcObject = remoteStream;

    // Set up a listener to handle ICE candidates generated by the STUN server
    peerConnection.onicecandidate = (event) => {
      if (event.candidate) {
        candidatevalue = event.candidate;
        socket.emit("candidate", candidatevalue);
      }
    };

    //  create a SDP offer and set it as a local decription  for local user
    offer = await peerConnection.createOffer();

    await peerConnection.setLocalDescription(offer);
    //   sending offer to another client
    socket.emit("offer", offer);
  } catch (error) {
    console.log(error);
  }
};

//  function to join meeting
const joinMeeting = () => {
  try {
    // CreateConnectionAndoffer();
   

  } catch (error) {
    console.log(error);
  }
};

// creating a socket functionality to check  connect remote user


socket.on("offer", async (offer) => {
  console.log("offer", offer);
  try {
    if (!peerConnection) {
      CreateConnectionAndoffer();
    }

    // setting a received offer as the remote description
    await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));

    // create an answer for local user and send it to remote  user for connection
    const answer = await peerConnection.createAnswer();

    await peerConnection.setLocalDescription(answer);
    socket.emit("answer", answer);
  } catch (error) {
    console.log(error);
  }
});
// now handle the incoming annswer from other user and join this metting

socket.on("answer", async (answer) => {
  console.log(answer, "answer");
  try {
    // Ensure peer connection is set up
    if (
      !peerConnection ||
      peerConnection.signalingState !== "have-local-offer"
    ) {
      console.warn(
        "Received answer in an unexpected signaling state:",
        peerConnection.signalingState
      );
      return;
    }

    await peerConnection.setRemoteDescription(
      new RTCSessionDescription(answer)
    );
  } catch (error) {
    console.log(error);
  }
});

// now handling incoming ICE candidate value form other user
socket.on("candidate", async (candidate) => {
  try {
    // now adding ice candidate value to our perr connecton
    if (peerConnection) {
      await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
    }
  } catch (error) {
    console.log(error);
  }
});

function closeConnection() {
  try {
    // Stop all local tracks
    if (localStream) {
      localStream.getTracks().forEach((track) => track.stop());
      console.log("Local tracks stopped.");
    }

    // Stop all remote tracks
    if (remoteStream) {
      remoteStream.getTracks().forEach((track) => track.stop());
      console.log("Remote tracks stopped.");
    }

    // Close the peer connection
    if (peerConnection) {
      peerConnection.close();
      peerConnection = null; // Clear the reference
      console.log("RTCPeerConnection closed.");
    }

    // Notify the other peer
    socket.emit("peer-disconnected");
    console.log("Signaling server notified of disconnection.");
  } catch (error) {
    console.error("Error while closing WebRTC connection:", error);
  }
}

// calling function to start the process
init();
